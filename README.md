## 1 Лабораторная работа: Решение задач линейного программирование
Автор: Сапожников А.А. МетОпт 1.1
### Пример
```text
Максимизировать: 2x + 3y + z + 4a
x + y + z + a <= 10
2x + y - z + a = 8
1y + 2z + a >= 5
```
### Код
#### Обработка данных из файла
```python
def parse_lp_text(text):
    # Очистка входных данных: удаляем пустые строки и лишние пробелы
    lines = [l.strip() for l in text.splitlines() if l.strip()]
    
    # Парсинг направления оптимизации (max/min)
    sense = lines[0].lower()
    
    # Парсинг коэффициентов целевой функции
    c = np.array([float(x) for x in lines[1].split()])
    
    # Парсинг ограничений: матрица A, знаки и правые части
    A, signs, b = [], [], []
    for line in lines[2:]:
        parts = line.split()
        *coeffs, sign, rhs = parts  # Разделяем коэффициенты, знак и правую часть
        A.append([float(x) for x in coeffs])
        signs.append(sign)
        b.append(float(rhs))
    
    return sense, np.array(c), np.array(A), signs, np.array(b)
```
#### Симплекс-метод
```python
def simplex(T, basis, maximize=True, tol=1e-9, verbose=False, phase_name=""):
    # Определение размеров таблицы (исключаем строку оценок и столбец правых частей)
    m = T.shape[0] - 1
    n = T.shape[1] - 1
    it = 0
    
    while True:
        it += 1
        
        # Анализ оценок для выбора включаемой переменной
        reduced = T[-1, :n]
        if maximize:
            # Для максимизации ищем положительные оценки
            candidates = np.where(reduced > tol)[0]
            if candidates.size == 0:
                # Все оценки неположительные - оптимум достигнут
                if verbose:
                    print(f"\n[{phase_name}] Итерация {it}: оптимум найден")
                return "optimal", T, basis
            e = candidates[np.argmax(reduced[candidates])]  # Выбор переменной с max оценкой
        else:
            # Для минимизации ищем отрицательные оценки
            candidates = np.where(reduced < -tol)[0]
            if candidates.size == 0:
                if verbose:
                    print(f"\n[{phase_name}] Итерация {it}: оптимум найден")
                return "optimal", T, basis
            e = candidates[np.argmin(reduced[candidates])]  # Выбор переменной с min оценкой

        # Определение исключаемой переменной по минимальному отношению
        col = T[:m, e]
        rhs = T[:m, -1]
        with np.errstate(divide="ignore", invalid="ignore"):
            ratio = np.where(col > tol, rhs / col, np.inf)  # Вычисление отношений b_i/a_ie
        
        # Проверка на неограниченность
        if np.all(np.isinf(ratio)):
            print(f"[{phase_name}] Неограниченность по переменной {e}")
            return "unbounded", T, basis
        
        l = np.argmin(ratio)  # Выбор ведущей строки

        # Отладочный вывод
        if verbose:
            print(f"\n[{phase_name}] --- Итерация {it} ---")
            print(f"Ведущий столбец (entering): {e}")
            print(f"Ведущая строка (leaving): {l}")
            print("Таблица до пивота:")
            print_tableau(T)
            print("Базис:", basis)

        # Выполнение шага жорданова исключения
        pivot_on(T, l, e)
        basis[l] = e  # Обновление базиса

        if verbose:
            print("После пивота:")
            print_tableau(T)
            print("Новый базис:", basis)
```
#### Двухфазный симплекс-метод
```python
def two_phase(sense, c, A, signs, b, verbose=False):
    m, n = A.shape

    # Фаза 1: Преобразование к канонической форме
    # Добавление slack/surplus переменных для приведения к равенствам
    A_eq, b_eq, add_vars = [], [], []
    for i in range(m):
        if signs[i] == "<=":
            # Для ≤ ограничений добавляем slack переменную
            row = np.hstack([A[i], np.eye(1, m, i)[0]])
            add_vars.append("slack")
        elif signs[i] == ">=":
            # Для ≥ ограничений вычитаем surplus переменную
            row = np.hstack([A[i], -np.eye(1, m, i)[0]])
            add_vars.append("surplus")
        else:  # "="
            # Для = ограничений не добавляем дополнительных переменных
            row = np.hstack([A[i], np.zeros(m)])
            add_vars.append("eq")
        A_eq.append(row)
        b_eq.append(b[i])

    A_eq = np.array(A_eq)
    b_eq = np.array(b_eq)
    n_total = A_eq.shape[1]  # Общее количество переменных после расширения

    # --- Фаза I: Поиск начального допустимого решения ---
    # Проверка необходимости искусственных переменных
    need_artificial = any(s in [">=", "="] for s in signs)

    if need_artificial:
        # Создание вспомогательной задачи для Фазы I
        I = np.eye(m)
        A1 = np.hstack([A_eq, I])  # Добавляем искусственные переменные
        c1 = np.hstack([np.zeros(n_total), np.ones(m)])  # Целевая функция: сумма искусственных переменных

        # Построение начальной симплекс-таблицы для Фазы I
        T1 = np.zeros((m + 1, A1.shape[1] + 1))
        T1[:m, :-1] = A1
        T1[:m, -1] = b_eq
        T1[-1, :-1] = c1
        T1[-1, -1] = np.sum(b_eq)
        
        # Корректировка строки оценок для получения допустимого базиса
        for i in range(m):
            T1[-1, :] -= T1[i, :]

        basis = list(range(n_total, n_total + m))  # Начальный базис из искусственных переменных
        
        # Решение вспомогательной задачи
        status1, T1_final, basis1 = simplex(
            T1, basis, maximize=True, verbose=verbose, phase_name="Фаза I"
        )

        if verbose:
            print("\n=== Конец Фазы I ===")
            print("Базис:", basis1)
            print("Таблица после Фазы I:")
            print_tableau(T1_final)
            print("====================\n")

        # Проверка существования допустимого решения
        if abs(T1_final[-1, -1]) > 1e-7:
            return {"status": "no feasible solution"}  # Нет допустимых решений

    else:
        # Если только ≤ ограничения, начальный базис уже допустим
        basis1 = list(range(n, n + m))

    # --- Фаза II: Решение исходной задачи ---
    # Построение таблицы для исходной задачи
    T2 = np.zeros((m + 1, n_total + 1))
    T2[:m, :n_total] = A_eq
    T2[:m, -1] = b_eq
    
    # Настройка целевой функции в зависимости от направления оптимизации
    if sense == "max":
        T2[-1, :n] = c
    else:
        T2[-1, :n] = -c  # Для минимизации меняем знак

    # Решение основной задачи симплекс-методом
    status2, T2_final, basis2 = simplex(
        T2, basis1.copy(), maximize=True, verbose=verbose, phase_name="Фаза II"
    )

    if verbose:
        print("\n=== Конец Фазы II ===")
        print("Финальная таблица:")
        print_tableau(T2_final)
        print("Базис:", basis2)
        print("====================\n")

    # Обработка результатов
    if status2 == "unbounded":
        return {"status": "unbounded"}

    # Восстановление решения
    x = np.zeros(n_total)
    for i, bi in enumerate(basis2):
        if bi < n_total:  # Исключаем искусственные переменные из решения
            x[bi] = T2_final[i, -1]

    # Вычисление значения целевой функции
    z = -T2_final[-1, -1] if sense == "max" else T2_final[-1, -1]
    
    return {"status": "optimal", "x": x[:n], "z": z}  # Возвращаем только исходные переменные
```
#### В файл example.lp введём сновные параметры задачи
```text
max
2 3 1 4
1 1 1 1 <= 10
2 1 -1 1 = 8
0 1 2 1 >= 5
```
#### В командной строке вводим
```text
python two_phase_simplex.py example.lp --verbose
```
### Результат
```text
[Фаза I] Неограниченность по переменной 6

=== Конец Фазы I ===
Базис: [7, 8, 9]
Таблица после Фазы I:
[[ 1.  1.  1.  1.  1.  0.  0.  1.  0.  0. 10.]
 [ 2.  1. -1.  1.  0.  0.  0.  0.  1.  0.  8.]
 [ 0.  1.  2.  1. -0. -0. -1.  0.  0.  1.  5.]
 [-3. -3. -2. -3. -1.  0.  1.  0.  0.  0.  0.]]
====================


[Фаза II] --- Итерация 1 ---
Ведущий столбец (entering): 3
Ведущая строка (leaving): 2
Таблица до пивота:
[[ 1.  1.  1.  1.  1.  0.  0. 10.]
 [ 2.  1. -1.  1.  0.  0.  0.  8.]
 [ 0.  1.  2.  1. -0. -0. -1.  5.]
 [ 2.  3.  1.  4.  0.  0.  0.  0.]]
Базис: [7, 8, 9]
После пивота:
[[  1.   0.  -1.   0.   1.   0.   1.   5.]
 [  2.   0.  -3.   0.   0.   0.   1.   3.]
 [  0.   1.   2.   1.  -0.  -0.  -1.   5.]
 [  2.  -1.  -7.   0.   0.   0.   4. -20.]]
Новый базис: [7, 8, np.int64(3)]

[Фаза II] --- Итерация 2 ---
Ведущий столбец (entering): 6
Ведущая строка (leaving): 1
Таблица до пивота:
[[  1.   0.  -1.   0.   1.   0.   1.   5.]
 [  2.   0.  -3.   0.   0.   0.   1.   3.]
 [  0.   1.   2.   1.  -0.  -0.  -1.   5.]
 [  2.  -1.  -7.   0.   0.   0.   4. -20.]]
Базис: [7, 8, np.int64(3)]
После пивота:
[[ -1.   0.   2.   0.   1.   0.   0.   2.]
 [  2.   0.  -3.   0.   0.   0.   1.   3.]
 [  2.   1.  -1.   1.   0.   0.   0.   8.]
 [ -6.  -1.   5.   0.   0.   0.   0. -32.]]
Новый базис: [7, np.int64(6), np.int64(3)]

[Фаза II] --- Итерация 3 ---
Ведущий столбец (entering): 2
Ведущая строка (leaving): 0
Таблица до пивота:
[[ -1.   0.   2.   0.   1.   0.   0.   2.]
 [  2.   0.  -3.   0.   0.   0.   1.   3.]
 [  2.   1.  -1.   1.   0.   0.   0.   8.]
 [ -6.  -1.   5.   0.   0.   0.   0. -32.]]
Базис: [7, np.int64(6), np.int64(3)]
После пивота:
[[ -0.5   0.    1.    0.    0.5   0.    0.    1. ]
 [  0.5   0.    0.    0.    1.5   0.    1.    6. ]
 [  1.5   1.    0.    1.    0.5   0.    0.    9. ]
 [ -3.5  -1.    0.    0.   -2.5   0.    0.  -37. ]]
Новый базис: [np.int64(2), np.int64(6), np.int64(3)]

[Фаза II] Итерация 4: оптимум найден

=== Конец Фазы II ===
Финальная таблица:
[[ -0.5   0.    1.    0.    0.5   0.    0.    1. ]
 [  0.5   0.    0.    0.    1.5   0.    1.    6. ]
 [  1.5   1.    0.    1.    0.5   0.    0.    9. ]
 [ -3.5  -1.    0.    0.   -2.5   0.    0.  -37. ]]
Базис: [np.int64(2), np.int64(6), np.int64(3)]
====================


=== РЕЗУЛЬТАТ ===
Результат: оптимально
x = [0. 0. 1. 9.]
Значение целевой функции = 37.0
```
### Вывод
  Реализация симплекс-метода оказалась исключительно полезной для глубокого понимания алгоритмов оптимизации, позволив перейти от теоретических знаний к практическому освоению двухфазного подхода, работы с матричными операциями и обработки особых случаев. Основные трудности, связанные с обеспечением численной устойчивости и корректной обработкой граничных условий, были успешно преодолены через введение допусков, добавление проверок на неограниченность и реализацию детального логгирования процесса. Этот опыт не только закрепил фундаментальные принципы линейного программирования, но и создал прочную основу для анализа результатов промышленных решателей и изучения более сложных методов оптимизации, демонстрируя ценность самостоятельной реализации классических алгоритмов для формирования комплексного понимания предметной области.
